"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.knownStaticMethods = exports.knownPrototypeMethods = exports.knownPipeableOperators = exports.knownOperators = exports.knownObservables = void 0;
var tslib_1 = require("tslib");
var fs = tslib_1.__importStar(require("fs"));
var path = tslib_1.__importStar(require("path"));
var semver = tslib_1.__importStar(require("semver"));
var peer = tslib_1.__importStar(require("./peer"));
var aliasOperators = { flatMap: "mergeMap" };
var prototypeMethods = semver.satisfies(peer.version, "<5.5.0-beta.5")
    ? {}
    : { pipe: true, toPromise: true };
function read(dir) {
    if (!peer.dir) {
        return {};
    }
    try {
        var names = fs.readdirSync(path.join(peer.dir, dir));
        return names
            .filter(function (name) { return /^[a-z]\w+\.js$/.test(name); })
            .map(function (name) { return name.replace(/\.js/, ""); })
            .filter(function (name) { return !prototypeMethods[name]; })
            .reduce(function (acc, name) {
            var _a;
            return (tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[name] = name, _a)));
        }, {});
    }
    catch (error) {
        peer.warn(dir);
    }
}
exports.knownObservables = read("add/observable");
exports.knownOperators = tslib_1.__assign(tslib_1.__assign({}, read("add/operator")), aliasOperators);
exports.knownPipeableOperators = tslib_1.__assign(tslib_1.__assign({}, read("operators")), aliasOperators);
exports.knownPrototypeMethods = tslib_1.__assign({ forEach: true }, prototypeMethods);
exports.knownStaticMethods = { create: true };
