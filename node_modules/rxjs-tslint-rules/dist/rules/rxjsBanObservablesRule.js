"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
var tslib_1 = require("tslib");
var Lint = tslib_1.__importStar(require("tslint"));
var tsutils = tslib_1.__importStar(require("tsutils"));
var used_walker_1 = require("../support/used-walker");
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));
    };
    Rule.metadata = {
        description: "Disallows the use of banned observables.",
        options: {
            type: "object",
        },
        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n      An object containing keys that are names of observable factory functions\n      and values that are either booleans or strings containing the explanation for the ban."], ["\n      An object containing keys that are names of observable factory functions\n      and values that are either booleans or strings containing the explanation for the ban."]))),
        requiresTypeInfo: true,
        ruleName: "rxjs-ban-observables",
        type: "functionality",
        typescriptOnly: true,
    };
    Rule.FAILURE_STRING = "RxJS observable is banned";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var Walker = (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker(sourceFile, rawOptions, program) {
        var _this = _super.call(this, sourceFile, rawOptions, program) || this;
        _this._bans = [];
        var _a = tslib_1.__read(_this.getOptions(), 1), options = _a[0];
        if (options) {
            Object.entries(options).forEach(function (_a) {
                var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                if (value !== false) {
                    _this._bans.push({
                        explanation: typeof value === "string" ? value : "",
                        regExp: new RegExp("^" + key + "$"),
                    });
                }
            });
        }
        return _this;
    }
    Walker.prototype.visitImportDeclaration = function (node) {
        var _this = this;
        var moduleSpecifier = node.moduleSpecifier.getText();
        if (/^['"]rxjs['"]/.test(moduleSpecifier)) {
            if (tsutils.isNamedImports(node.importClause.namedBindings)) {
                node.importClause.namedBindings.elements.forEach(function (binding) {
                    _this.validateNode(binding.propertyName || binding.name);
                });
            }
        }
        else {
            var match = moduleSpecifier.match(/^['"]rxjs(?:\/add)?\/observable\/(\w+)['"]/);
            if (match) {
                var failure = this.getFailure(match[1]);
                if (failure) {
                    this.addFailureAtNode(node.moduleSpecifier, failure);
                }
            }
        }
        _super.prototype.visitImportDeclaration.call(this, node);
    };
    Walker.prototype.onSourceFileEnd = function () {
        var _this = this;
        Object.entries(this.usedObservables).forEach(function (_a) {
            var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
            var failure = _this.getFailure(key);
            if (failure) {
                value.forEach(function (node) { return _this.addFailureAtNode(node, failure); });
            }
        });
    };
    Walker.prototype.getFailure = function (name) {
        var _bans = this._bans;
        for (var b = 0, length_1 = _bans.length; b < length_1; ++b) {
            var ban = _bans[b];
            if (ban.regExp.test(name)) {
                var explanation = ban.explanation ? ": " + ban.explanation : "";
                return Rule.FAILURE_STRING + ": " + name + explanation;
            }
        }
        return undefined;
    };
    Walker.prototype.validateNode = function (name) {
        var failure = this.getFailure(name.getText());
        if (failure) {
            this.addFailureAtNode(name, failure);
        }
    };
    return Walker;
}(used_walker_1.UsedWalker));
var templateObject_1;
