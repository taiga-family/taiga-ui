"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
var tslib_1 = require("tslib");
var tsquery_1 = require("@phenomnomnominal/tsquery");
var Lint = tslib_1.__importStar(require("tslint"));
var peer = tslib_1.__importStar(require("../support/peer"));
var util_1 = require("../support/util");
var defaultTypesRegExp = /^EventEmitter$/;
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var _this = this;
        var failures = [];
        var typeChecker = program.getTypeChecker();
        var suffix = "Subject";
        var types = [];
        var validateOptions = {
            parameters: true,
            properties: true,
            variables: true,
        };
        var message = function (identifier) {
            return "Subject '" + identifier + "' must be suffixed with '" + suffix + "'.";
        };
        var ruleArguments = this.getOptions().ruleArguments;
        var _a = tslib_1.__read(ruleArguments, 1), options = _a[0];
        if (options) {
            suffix = options.suffix;
            if (options.types) {
                Object.entries(options.types).forEach(function (_a) {
                    var _b = tslib_1.__read(_a, 2), key = _b[0], validate = _b[1];
                    types.push({ regExp: new RegExp(key), validate: validate });
                });
            }
            else {
                types.push({ regExp: defaultTypesRegExp, validate: false });
            }
            validateOptions = tslib_1.__assign(tslib_1.__assign({}, validateOptions), options);
        }
        else {
            types.push({ regExp: defaultTypesRegExp, validate: false });
        }
        var suffixRegex = new RegExp(String.raw(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["", "$?$"], ["", "\\$?$"])), suffix), "i");
        var identifiers = [];
        if (validateOptions.parameters) {
            identifiers = identifiers.concat(tsquery_1.tsquery(sourceFile, "Parameter > Identifier"));
        }
        if (validateOptions.properties) {
            identifiers = identifiers.concat(tsquery_1.tsquery(sourceFile, ":matches(PropertyAssignment, PropertyDeclaration, PropertySignature, GetAccessor, SetAccessor) > Identifier"));
        }
        if (validateOptions.variables) {
            identifiers = identifiers.concat(tsquery_1.tsquery(sourceFile, "VariableDeclaration > Identifier"));
        }
        identifiers.forEach(function (identifier) {
            var type = typeChecker.getTypeAtLocation(identifier);
            var text = identifier.getText();
            if (!suffixRegex.test(text) && util_1.couldBeType(type, "Subject")) {
                for (var i = 0; i < types.length; ++i) {
                    var _a = types[i], regExp = _a.regExp, validate = _a.validate;
                    if (util_1.couldBeType(type, regExp) && !validate) {
                        return;
                    }
                }
                failures.push(new Lint.RuleFailure(sourceFile, identifier.getStart(), identifier.getStart() + identifier.getWidth(), message(text), _this.ruleName));
            }
        });
        return failures;
    };
    Rule.metadata = {
        deprecationMessage: peer.v5 ? peer.v5NotSupportedMessage : undefined,
        description: "Disalllows subjects that don't end with the specified `suffix` option.",
        options: {
            properties: {
                parameters: { type: "boolean" },
                properties: { type: "boolean" },
                suffix: { type: "string" },
                types: { type: "object" },
                variables: { type: "boolean" },
            },
            type: "object",
        },
        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject(["\n      An optional object with optional `parameters`, `properties` and `variables` properties.\n      The properties are booleans and determine whether or not subjects used in those situations need a suffix.\n      `parameters`, `properties` and `variables` default to `true`, and the default suffix is 'Subject'.\n      The object also has optional `types` properties which are themselves\n      objects containing keys that are regular expressions and values that are booleans -\n      indicating whether suffixing is required for particular types."], ["\n      An optional object with optional \\`parameters\\`, \\`properties\\` and \\`variables\\` properties.\n      The properties are booleans and determine whether or not subjects used in those situations need a suffix.\n      \\`parameters\\`, \\`properties\\` and \\`variables\\` default to \\`true\\`, and the default suffix is 'Subject'.\n      The object also has optional \\`types\\` properties which are themselves\n      objects containing keys that are regular expressions and values that are booleans -\n      indicating whether suffixing is required for particular types."]))),
        requiresTypeInfo: true,
        ruleName: "rxjs-suffix-subjects",
        type: "style",
        typescriptOnly: true,
    };
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var templateObject_1, templateObject_2;
