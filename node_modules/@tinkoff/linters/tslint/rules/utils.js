"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var tsutils_1 = require("tsutils");
var tslint_1 = require("tslint");
function getLeadingWhitespace(node, sourceFile) {
    var fromLine = ts.getLineAndCharacterOfPosition(sourceFile, node.getStart()).line;
    return getWhitespace(sourceFile, fromLine);
}
exports.getLeadingWhitespace = getLeadingWhitespace;
function getTrailingWhitespace(node, sourceFile) {
    var next = tsutils_1.getNextStatement(node);
    var fromLine = ts.getLineAndCharacterOfPosition(sourceFile, next.getStart()).line;
    return getWhitespace(sourceFile, fromLine);
}
exports.getTrailingWhitespace = getTrailingWhitespace;
function getWhitespace(sourceFile, fromLine) {
    var whitespaceScanner = ts.createScanner(ts.ScriptTarget.ES5, false, ts.LanguageVariant.Standard, sourceFile.text);
    whitespaceScanner.setTextPos(sourceFile.getLineStarts()[fromLine]);
    var whitespace = '';
    do {
        whitespace += whitespaceScanner.getTokenText();
        whitespaceScanner.scan();
    } while (whitespaceScanner.getToken() === ts.SyntaxKind.WhitespaceTrivia);
    return whitespace;
}
var NewLineRuleWalker = /** @class */ (function (_super) {
    __extends(NewLineRuleWalker, _super);
    function NewLineRuleWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NewLineRuleWalker.prototype.walk = function (sourceFile) {
        var _this = this;
        var cb = function (node) {
            if (_this.hasMatch(node)) {
                _this.visitStatement(node);
            }
            return ts.forEachChild(node, cb);
        };
        ts.forEachChild(sourceFile, cb);
    };
    NewLineRuleWalker.prototype.visitStatement = function (node) {
        this.verifyLineBefore(node);
        this.verifyLineAfter(node);
    };
    NewLineRuleWalker.prototype.verifyLineBefore = function (node) {
        var prev = tsutils_1.getPreviousStatement(node);
        if (!prev || this.shouldSkipPrevious(node, prev)) {
            return;
        }
        var start = node.getStart(this.sourceFile);
        var line = ts.getLineAndCharacterOfPosition(this.sourceFile, start).line;
        var comments = ts.getLeadingCommentRanges(this.sourceFile.text, node.pos);
        if (comments !== undefined) {
            // check for blank lines between comments
            for (var i = comments.length - 1; i >= 0; --i) {
                var endLine = ts.getLineAndCharacterOfPosition(this.sourceFile, comments[i].end).line;
                if (endLine < line - 1) {
                    return;
                }
                start = comments[i].pos;
                line = ts.getLineAndCharacterOfPosition(this.sourceFile, start).line;
            }
        }
        var prevLine = ts.getLineAndCharacterOfPosition(this.sourceFile, prev.end).line;
        if (prevLine >= line - 1) {
            var whitespace = getLeadingWhitespace(node, this.sourceFile);
            var replacement = new tslint_1.Replacement(prev.getEnd(), start - prev.getEnd(), "\n\n" + whitespace);
            this.addFailureAtNode(node.getFirstToken(), this.getFailureString(), replacement);
        }
    };
    NewLineRuleWalker.prototype.verifyLineAfter = function (node) {
        var next = tsutils_1.getNextStatement(node);
        if (!next || this.shouldSkipNext(node, next)) {
            return;
        }
        var start = next.getStart();
        var end = node.getEnd();
        var line = ts.getLineAndCharacterOfPosition(this.sourceFile, end).line;
        var nextLine = ts.getLineAndCharacterOfPosition(this.sourceFile, start).line;
        var comments = ts.getTrailingCommentRanges(this.sourceFile.text, end) ||
            ts.getLeadingCommentRanges(this.sourceFile.text, next.pos);
        if (comments !== undefined) {
            // check for blank lines between comments
            for (var i = comments.length - 1; i >= 0; --i) {
                var startLine = ts.getLineAndCharacterOfPosition(this.sourceFile, comments[i].pos).line;
                if (startLine === line && comments[i].end < next.getStart()) {
                    end = comments[i].end;
                    line = ts.getLineAndCharacterOfPosition(this.sourceFile, end).line;
                }
                else {
                    start = comments[i].pos;
                    nextLine = ts.getLineAndCharacterOfPosition(this.sourceFile, start)
                        .line;
                }
            }
        }
        if (nextLine <= line + 1) {
            var whitespace = getTrailingWhitespace(node, this.sourceFile);
            var replacement = new tslint_1.Replacement(end, start - end, "\n\n" + whitespace);
            this.addFailureAtNode(node.getLastToken(), this.getFailureString(), replacement);
        }
    };
    NewLineRuleWalker.prototype.shouldSkipPrevious = function (node, previous) {
        return this.hasMatch(previous);
    };
    NewLineRuleWalker.prototype.shouldSkipNext = function (node, next) {
        return this.hasMatch(next);
    };
    return NewLineRuleWalker;
}(tslint_1.AbstractWalker));
exports.NewLineRuleWalker = NewLineRuleWalker;
// Angular member ordering rule
exports.defaultMemberData = {
    'public-static-field': {
        rank: 0,
        text: 'PUBLIC STATIC property',
    },
    'protected-static-field': {
        rank: 1,
        text: 'PROTECTED STATIC property',
    },
    'private-static-field': {
        rank: 2,
        text: 'PRIVATE STATIC property',
    },
    'public-static-method': {
        rank: 3,
        text: 'PUBLIC STATIC METHOD',
    },
    'protected-static-method': {
        rank: 4,
        text: 'PROTECTED STATIC METHOD',
    },
    'private-static-method': {
        rank: 5,
        text: 'PRIVATE STATIC METHOD',
    },
    '@Input': {
        rank: 6,
        text: '@Input',
    },
    '@Output': {
        rank: 7,
        text: '@Output',
    },
    'public-getter': {
        rank: 8,
        text: 'PUBLIC GETTER',
    },
    'public-setter': {
        rank: 9,
        text: 'PUBLIC SETTER',
    },
    'protected-getter': {
        rank: 10,
        text: 'PROTECTED GETTER',
    },
    'protected-setter': {
        rank: 11,
        text: 'PROTECTED SETTER',
    },
    'private-getter': {
        rank: 12,
        text: 'PRIVATE GETTER',
    },
    'private-setter': {
        rank: 13,
        text: 'PRIVATE SETTER',
    },
    'public-instance-field': {
        rank: 14,
        text: 'PUBLIC INSTANCE property',
    },
    'protected-instance-field': {
        rank: 15,
        text: 'PROTECTED INSTANCE property',
    },
    'private-instance-field': {
        rank: 16,
        text: 'PRIVATE INSTANCE property',
    },
    'public-instance-method': {
        rank: 17,
        text: 'PUBLIC INSTANCE METHOD',
    },
    'protected-instance-method': {
        rank: 18,
        text: 'PROTECTED INSTANCE METHOD',
    },
    'private-instance-method': {
        rank: 19,
        text: 'PRIVATE INSTANCE METHOD',
    },
};
var AngularMemberOrderingWalker = /** @class */ (function (_super) {
    __extends(AngularMemberOrderingWalker, _super);
    function AngularMemberOrderingWalker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lastPropertyDeclaration = null;
        _this.visitVariableDeclaration = function (node) {
            if (_this.lastPropertyDeclaration === null) {
                _this.lastPropertyDeclaration = node;
                return;
            }
            if (!_this.isRightOrder(node, _this.lastPropertyDeclaration)) {
                _this.addFailureAt(node.getStart(), _this.nodeWidth(node), _this.getFailureString(node, _this.lastPropertyDeclaration));
            }
            else if (_this.wrongWithAccessor(node, _this.lastPropertyDeclaration)) {
                _this.addFailureAt(_this.lastPropertyDeclaration.getStart(), _this.nodeWidth(_this.lastPropertyDeclaration), _this.getFailureStringForAccessor(_this.lastPropertyDeclaration));
            }
            _this.lastPropertyDeclaration = node;
        };
        return _this;
    }
    AngularMemberOrderingWalker.prototype.walk = function (sourceFile) {
        var _this = this;
        var cb = function (node) {
            if (_this.isClass(node)) {
                _this.lastPropertyDeclaration = null;
            }
            if (_this.hasMatch(node)) {
                _this.visitVariableDeclaration(node);
            }
            return ts.forEachChild(node, cb);
        };
        ts.forEachChild(sourceFile, cb);
    };
    return AngularMemberOrderingWalker;
}(tslint_1.AbstractWalker));
exports.AngularMemberOrderingWalker = AngularMemberOrderingWalker;
