import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { InjectionToken, Attribute, Directive, Inject, Optional, ElementRef, Injectable, NgModule, inject } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'rxjs';
const INTERSECTION_ROOT = new InjectionToken('Root element for IntersectionObserver');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_ROOT_MARGIN_DEFAULT = '0px 0px 0px 0px';
/** @type {?} */
const INTERSECTION_ROOT_MARGIN = new InjectionToken('rootMargin for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_ROOT_MARGIN_DEFAULT,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rootMargin
 * @return {?}
 */
function rootMarginFactory(rootMargin) {
    return rootMargin || INTERSECTION_ROOT_MARGIN_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_THRESHOLD_DEFAULT = 0;
/** @type {?} */
const INTERSECTION_THRESHOLD = new InjectionToken('threshold for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_THRESHOLD_DEFAULT,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} threshold
 * @return {?}
 */
function thresholdFactory(threshold) {
    return threshold
        ? threshold.split(',').map(parseFloat)
        : INTERSECTION_THRESHOLD_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverDirective extends IntersectionObserver {
    /**
     * @param {?} root
     * @param {?} rootMargin
     * @param {?} threshold
     */
    constructor(root, rootMargin, threshold) {
        super(entries => {
            this.callbacks.forEach((callback, element) => {
                /** @type {?} */
                const filtered = entries.filter(({ target }) => target === element);
                return filtered.length && callback(filtered, this);
            });
        }, {
            root: root && root.nativeElement,
            rootMargin: rootMarginFactory(rootMargin),
            threshold: thresholdFactory(threshold),
        });
        this.callbacks = new Map();
    }
    /**
     * @param {?} target
     * @param {?=} callback
     * @return {?}
     */
    observe(target, callback = () => { }) {
        super.observe(target);
        this.callbacks.set(target, callback);
    }
    /**
     * @param {?} target
     * @return {?}
     */
    unobserve(target) {
        super.unobserve(target);
        this.callbacks.delete(target);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disconnect();
    }
}
IntersectionObserverDirective.ɵfac = function IntersectionObserverDirective_Factory(t) { return new (t || IntersectionObserverDirective)(ɵngcc0.ɵɵdirectiveInject(INTERSECTION_ROOT, 8), ɵngcc0.ɵɵinjectAttribute('waIntersectionRootMargin'), ɵngcc0.ɵɵinjectAttribute('waIntersectionThreshold')); };
IntersectionObserverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserverDirective, selectors: [["", "waIntersectionObserver", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
IntersectionObserverDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionRootMargin',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionThreshold',] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionObserver]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [INTERSECTION_ROOT]
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['waIntersectionRootMargin']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['waIntersectionThreshold']
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserveeService extends Observable {
    /**
     * @param {?} __0
     * @param {?} observer
     */
    constructor({ nativeElement }, observer) {
        super(subscriber => {
            observer.observe(nativeElement, entries => {
                subscriber.next(entries);
            });
            return () => {
                observer.unobserve(nativeElement);
            };
        });
        return this.pipe(share());
    }
}
IntersectionObserveeService.ɵfac = function IntersectionObserveeService_Factory(t) { return new (t || IntersectionObserveeService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(IntersectionObserverDirective)); };
IntersectionObserveeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserveeService, factory: IntersectionObserveeService.ɵfac });
/** @nocollapse */
IntersectionObserveeService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IntersectionObserverDirective, decorators: [{ type: Inject, args: [IntersectionObserverDirective,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: IntersectionObserverDirective, decorators: [{
                type: Inject,
                args: [IntersectionObserverDirective]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class IntersectionObserveeDirective {
    /**
     * @param {?} waIntersectionObservee
     */
    constructor(waIntersectionObservee) {
        this.waIntersectionObservee = waIntersectionObservee;
    }
}
IntersectionObserveeDirective.ɵfac = function IntersectionObserveeDirective_Factory(t) { return new (t || IntersectionObserveeDirective)(ɵngcc0.ɵɵdirectiveInject(IntersectionObserveeService)); };
IntersectionObserveeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionObserveeDirective, selectors: [["", "waIntersectionObservee", ""]], outputs: { waIntersectionObservee: "waIntersectionObservee" }, features: [ɵngcc0.ɵɵProvidersFeature([IntersectionObserveeService])] });
/** @nocollapse */
IntersectionObserveeDirective.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [IntersectionObserveeService,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserveeDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionObservee]',
                outputs: ['waIntersectionObservee'],
                providers: [IntersectionObserveeService]
            }]
    }], function () { return [{ type: ɵngcc1.Observable, decorators: [{
                type: Inject,
                args: [IntersectionObserveeService]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionRootDirective {
}
IntersectionRootDirective.ɵfac = function IntersectionRootDirective_Factory(t) { return new (t || IntersectionRootDirective)(); };
IntersectionRootDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IntersectionRootDirective, selectors: [["", "waIntersectionRoot", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: INTERSECTION_ROOT,
                useExisting: ElementRef
            },
        ])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionRootDirective, [{
        type: Directive,
        args: [{
                selector: '[waIntersectionRoot]',
                providers: [
                    {
                        provide: INTERSECTION_ROOT,
                        useExisting: ElementRef
                    },
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverModule {
}
IntersectionObserverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntersectionObserverModule });
IntersectionObserverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntersectionObserverModule_Factory(t) { return new (t || IntersectionObserverModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntersectionObserverModule, { declarations: [IntersectionObserverDirective,
        IntersectionObserveeDirective,
        IntersectionRootDirective], exports: [IntersectionObserverDirective,
        IntersectionObserveeDirective,
        IntersectionRootDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ],
                exports: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_OBSERVER_SUPPORT = new InjectionToken('Intersection Observer API support', {
    providedIn: 'root',
    factory: () => !!inject(WINDOW).IntersectionObserver,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverService extends Observable {
    /**
     * @param {?} __0
     * @param {?} support
     * @param {?} rootMargin
     * @param {?} threshold
     * @param {?} root
     */
    constructor({ nativeElement }, support, rootMargin, threshold, root) {
        super(subscriber => {
            if (!support) {
                subscriber.error('IntersectionObserver is not supported in your browser');
                return;
            }
            /** @type {?} */
            const observer = new IntersectionObserver(entries => {
                subscriber.next(entries);
            }, {
                root: root && root.nativeElement,
                rootMargin,
                threshold,
            });
            observer.observe(nativeElement);
            return () => {
                observer.disconnect();
            };
        });
        return this.pipe(share());
    }
}
IntersectionObserverService.ɵfac = function IntersectionObserverService_Factory(t) { return new (t || IntersectionObserverService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(INTERSECTION_OBSERVER_SUPPORT), ɵngcc0.ɵɵinject(INTERSECTION_ROOT_MARGIN), ɵngcc0.ɵɵinject(INTERSECTION_THRESHOLD), ɵngcc0.ɵɵinject(INTERSECTION_ROOT, 8)); };
IntersectionObserverService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntersectionObserverService, factory: IntersectionObserverService.ɵfac });
/** @nocollapse */
IntersectionObserverService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [INTERSECTION_OBSERVER_SUPPORT,] }] },
    { type: String, decorators: [{ type: Inject, args: [INTERSECTION_ROOT_MARGIN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [INTERSECTION_THRESHOLD,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntersectionObserverService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: Boolean, decorators: [{
                type: Inject,
                args: [INTERSECTION_OBSERVER_SUPPORT]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [INTERSECTION_ROOT_MARGIN]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [INTERSECTION_THRESHOLD]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [INTERSECTION_ROOT]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IntersectionObserveeDirective, IntersectionObserverDirective, IntersectionRootDirective, IntersectionObserverModule, IntersectionObserveeService, IntersectionObserverService, INTERSECTION_ROOT, INTERSECTION_ROOT_MARGIN_DEFAULT, INTERSECTION_ROOT_MARGIN, INTERSECTION_THRESHOLD_DEFAULT, INTERSECTION_THRESHOLD, INTERSECTION_OBSERVER_SUPPORT };

//# sourceMappingURL=ng-web-apis-intersection-observer.js.map