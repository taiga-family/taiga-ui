{"version":3,"file":"external-module-id-strategy.js","sourceRoot":"","sources":["../../../src/lib/flatten/external-module-id-strategy.ts"],"names":[],"mappings":";;AAAA,6BAA6B;AAU7B,MAAa,wBAAwB;IACnC,YAAoB,YAAiC,EAAU,cAA8B;QAAzE,iBAAY,GAAZ,YAAY,CAAqB;QAAU,mBAAc,GAAd,cAAc,CAAgB;IAAG,CAAC;IAEjG,8DAA8D;IAC9D,oBAAoB,CAAC,QAAgB;QACnC,oEAAoE;QACpE,yFAAyF;QACzF,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACrF,yGAAyG;YACzG,OAAO,KAAK,CAAC;SACd;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;QACnD,IACE,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;YACtB,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,IAAI,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACtE,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,EAC7B;YACA,OAAO,KAAK,CAAC;SACd;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,yBAAyB;QACvB,MAAM,EAAE,mBAAmB,GAAG,EAAE,EAAE,YAAY,GAAG,EAAE,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC;QAE5E,qGAAqG;QACrG,qFAAqF;QACrF,qCAAqC;QACrC,IAAI,IAAI,CAAC,YAAY,KAAK,KAAK,EAAE;YAC/B,OAAO,GAAG,CAAC,CAAC,wBAAwB;SACrC;QAED,kDAAkD;QAClD,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE;YACpC,OAAO,iBAAiB,CAAC;SAC1B;QAED,wDAAwD;QACxD,OAAO,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACtE,CAAC;CACF;AA7CD,4DA6CC","sourcesContent":["import * as path from 'path';\nimport * as rollup from 'rollup';\n\nexport interface DependencyList {\n  /** Direct dependencies including peerDependencies and other entry points. */\n  dependencies?: string[];\n  /** Direct bundled dependencies */\n  bundledDependencies?: string[];\n}\n\nexport class ExternalModuleIdStrategy {\n  constructor(private moduleFormat: rollup.ModuleFormat, private dependencyList: DependencyList) {}\n\n  /** Return true when moduleId is to be treated as external  */\n  isExternalDependency(moduleId: string): boolean {\n    // more information about why we don't check for 'node_modules' path\n    // https://github.com/rollup/rollup-plugin-node-resolve/issues/110#issuecomment-350353632\n    if (path.isAbsolute(moduleId) || moduleId.startsWith('.') || moduleId.startsWith('/')) {\n      // if it's either 'absolute', marked to embed, starts with a '.' or '/' or is the umd bundle and is tslib\n      return false;\n    }\n\n    const externals = this.getNonBundledDependencies();\n    if (\n      Array.isArray(externals)\n        ? !externals.some(x => x === moduleId || moduleId.startsWith(`${x}/`))\n        : !externals.test(moduleId)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a array of strings or a RegExp of non-bundled dependencies.\n   */\n  getNonBundledDependencies(): string[] | RegExp {\n    const { bundledDependencies = [], dependencies = [] } = this.dependencyList;\n\n    // return catch all for when there are no 'bundledDependencies' is very important for secondary entry\n    // as if this is not the case everything will be bundled in the secondary entry point\n    // since no dependencies are defined.\n    if (this.moduleFormat !== 'umd') {\n      return /./; // catch all as external\n    }\n\n    // tslib should always be embeeded for umd modules\n    if (bundledDependencies.length === 0) {\n      return /^((?!tslib).)*$/;\n    }\n\n    // filter out dependencies that are meant to be external\n    return dependencies.filter(x => bundledDependencies.indexOf(x) < 0);\n  }\n}\n"]}