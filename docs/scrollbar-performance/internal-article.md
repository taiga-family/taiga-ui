# Внутренняя статья: производительность кастомного скроллбара Taiga UI

Эта версия — для команды разработки Taiga UI. Здесь собрана полная техническая картина: все экспериментальные варианты, параметры конфигурации, сценарии тестов, методология, метрики CDP, результаты с обновлёнными числами, а также практические рекомендации.

## Содержание

1. Введение и цель работ
2. Обзор компонентов и архитектуры
3. Конфигурация и флаги рантайма
4. Сценарии тестирования
5. Методика измерений (CDP + статистика)
6. Что именно считаем (маппинг событий CDP)
7. Варианты экспериментов (матрица)
8. Свежие результаты и интерпретация
9. Рекомендации по настройке и дефолтам
10. Как запускать локально / в CI
11. Приложения: сводки, графики, расширенные сценарии

---

## 1) Введение и цель работ

Задача — оценить и улучшить производительность `TuiScrollbar` в реальных сценариях, сравнить классический polling через `requestAnimationFrame` с событийной архитектурой (ResizeObserver + MutationObserver) и с вариантом, использующим GPU‑дружественные `transform` вместо layout‑свойств.

Ключевая цель — минимизировать «дорогие» Layout операции (и их разброс), сохранив отзывчивость и корректность визуального «бегунка». Для объективности используем CDP‑трассировку и автоматизированные сценарии в Playwright.

## 2) Обзор компонентов и архитектуры

- `projects/core/components/scrollbar/scrollbar.component.ts` — контейнер, делегирует управление «бегунком».
- `projects/core/components/scrollbar/scroll-controls.component.ts` — отвечает за видимость/наличие полос (вертикальная/горизонтальная), обновление по событиям. Имеет два режима:
  - RAF (исторический/базовый) — опрашивает состояние с `requestAnimationFrame`.
  - Событийный — реагирует на Resize/Mutation/Scroll.
- `projects/core/components/scrollbar/scrollbar.directive.ts` — считает положение и размер «бегунка»; поддерживает как CPU‑путь (top/left/width/height), так и GPU‑дружественный путь (transform/scale).

## 3) Конфигурация и флаги рантайма (sessionStorage)

Все ключевые параметры задаются флагами в `sessionStorage` (это позволяет честно гонять эксперименты без перекомпиляции):

- Общие тайминги
  - `tui-scrollbar-debounce`: число (мс) для debounce RO/MO пути директивы
  - `tui-scrollbar-throttle`: число (мс) для throttle scroll‑событий и RAF‑пути директивы
  - `tui-scroll-controls-debounce`: число (мс) для debounce в `scroll-controls`
  - `tui-scroll-controls-throttle`: число (мс) для throttle в `scroll-controls`
- Режимы
  - `tui-scrollbar-raf` = '1' — включает RAF‑ветку в директиве (baseline)
  - `tui-scroll-controls-raf` = '1' — включает RAF‑ветку в `scroll-controls`
  - `tui-scrollbar-no-mutation` = '1' — отключить MutationObserver (эксперименты)
  - `tui-scrollbar-transform` = '1' — включить GPU‑путь (transform/scale)
  - `tui-scrollbar-pipeline` = 'audit' | 'throttle' — выбор оператора для scroll‑потока

Эти флаги выставляются из Playwright перед перезагрузкой страницы, чтобы сценарии проходили в строго детерминированной конфигурации.

## 4) Сценарии тестирования

В `projects/demo-playwright/tests/core/scrollbar/scrollbar-performance.pw.spec.ts` реализована комбинированная «прокрутка» с тремя фазами на наборах примеров `tui-doc-example`:

1) Прокрутка (scroll‑фаза)
- Последовательные приращения `scrollTop`, короткие паузы, фиксированный шаг — провоцируем обновления «бегунка» и обработку scroll‑потока.

2) Динамический контент (content‑фаза)
- Периодически добавляем небольшие `div` внутрь первого `tui-scrollbar`, чтобы вызвать пересчёт размеров (Resize) и потенциальные RecalculateStyle/Layout.

3) Стилевая нагрузка без геометрии (style‑only‑фаза)
- Массово переключаем класс `t-style-toggle` у потомков, меняем CSS‑переменную `--tui-perf-hue` на `:root`. Это инвалидирует стиль‑дерево (RecalculateStyle) без явных геометрических сдвигов, моделируя «тяжёлые темы», атрибутные селекторы и пр.

## 5) Методика измерений

- CDP Tracing (через Playwright CDPSession): включаем категории `devtools.timeline`, `blink.user_timing`, дополнительно `blink_style`, `blink`.
- Сбор событий и последующая фильтрация по именам (см. маппинг ниже).
- Статистика:
  - Многократные прогоны (обычно 15–20 в CI; 30–50 для «вылизанных» интервалов).
  - Фильтрация выбросов (IQR) перед расчётом средних.
  - Считаем среднее, стандартное отклонение, 95% доверительные интервалы.

## 6) Маппинг событий CDP → метрики

- Layout:
  - `name === 'Layout'`
- RecalculateStyle:
  - `name === 'RecalculateStyles'` или `name === 'UpdateLayoutTree'`
  - В некоторых версиях Chrome релевантен `Document::recalcStyle` (мы учитываем этот кейс тоже при необходимости).

Метрики на прогонах:

- `layoutCount`, `layoutDuration`
- `recalcStyleCount`, `recalcStyleDuration`

## 7) Матрица вариантов (ключевые)

- `original-raf-complete` — RAF и в `scroll-controls`, и в директиве (исторический baseline)
- `event-driven-full` — ResizeObserver + MutationObserver (событийная архитектура)
- `event-driven-gpu` — событийная архитектура + GPU‑дружественные `transform/scale`

Тайминги для честных сравнений можно выравнивать (например, debounce=50ms, throttle=16ms) через sessionStorage.

## 8) Свежие результаты (выравненные тайминги: debounce=50, throttle=16; 20 прогонов)

| Вариант | Layout (операции) | RecalcStyle (операции) | Время Layout (мс) | Время Recalc (мс) |
|---------|--------------------|------------------------|-------------------|-------------------|
| База (RAF: scroll‑controls + directive) | 76.0 ± 60.6 | 781.8 ± 84.2 | 22.63 ± 5.87 | 46.41 ± 8.02 |
| События (Resize + Mutation) | 75.8 ± 59.4 | 90.8 ± 64.5 | 23.29 ± 6.23 | 25.32 ± 5.67 |
| События + GPU (transform) | 40.3 ± 1.31 | 145.9 ± 79.4 | 18.37 ± 6.66 | 29.22 ± 7.38 |

Замечания по интерпретации:

- GPU‑вариант уверенно минимизирует Layout и даёт наилучшую стабильность по счётчику Layout. Это критично для плавности прокрутки.
- RecalculateStyle может быть выше у GPU‑варианта, особенно на style‑only фазе — это ожидаемо, т.к. мы переносим работу из Layout в Style (меняем `transform` и активно переключаем классы/переменные).
- Событийный «full» вариант показывает минимальную стоимость по RecalcStyle в сценариях с активной стилевой нагрузкой и редкими геометрическими изменениями.
- RAF (polling) в выравненных таймингах демонстрирует сильно возросший RecalcStyle на style‑only фазе — как базовый слой, он хуже управляет избыточной работой движка.

### 8.1) Итоги свипа задержек (debounce/throttle)

На свипе задержек для трёх архитектур (RAF, события, события+GPU) наблюдается следующее:

- RAF (baseline polling): при 0 ms достигается идеальная синхронизация с кадром, но в нашем сценарии со style‑only фазой счётчик RecalculateStyle существенно возрастает. Практический компромисс — не использовать 0 ms в продакшене, а ограничиться ≥16 ms. В целом RAF не рекомендуем как дефолтный режим.
- Событийная архитектура (Resize+Mutation): рост задержек снижает шум и стоимость RecalcStyle/Layout, но ухудшает отзывчивость. Компромисс для продакшена — throttle ≈ 16 ms, debounce ≈ 50 ms.
- События + GPU (transform/scale): Layout стабилен (~40 операций) во всём диапазоне; увеличение debounce снижает RecalcStyle, но повышает латентность реакции на изменения размеров. Оптимальный баланс — throttle ≈ 16 ms, debounce ≈ 50 ms.

Сырые результаты свипа сохраняются в `projects/demo-playwright/tests/tests-results/scrollbar-performance-results.json`.

## 9) Рекомендации

- Дефолт для библиотеки: «События + GPU» (transform), тайминги: debounce=50ms, throttle=16ms.
- Для страниц с экстремально «стилевой» нагрузкой и редкими геометрическими изменениями можно рассмотреть «События (full)» без GPU, если визуально разницы нет, а стиль‑дерево более стабильное.
- Избегать RAF‑polling как дефолт.

## 10) Как запускать

1) Старт демо‑сервера: `npm start` (порт 3333)
2) Запуск перф‑тестов (пример, 20 прогонов, 3 варианта):

```
TUI_PERF_RUNS=20 npx playwright test \
  projects/demo-playwright/tests/core/scrollbar/scrollbar-performance.pw.spec.ts \
  -g "original-raf-complete|event-driven-full|event-driven-gpu" \
  --reporter=list
```

Результаты: `projects/demo-playwright/tests/tests-results/scrollbar-performance-results.json` и логи в консоли.

## 11) Приложения

- Сырые результаты и сводки: `projects/demo-playwright/tests/tests-results/scrollbar-performance-results.json`
- Параметры конфигурации (sessionStorage): см. раздел 3
- Быстрые свипы таймингов: можно варьировать `debounceMs/throttleMs` в конфигурациях тестов для выбора компромисса «отзывчивость ↔ шум».

---

Если захотите воспроизвести любой конкретный эксперимент из прошлых серий — поднимите нужные флаги в конфиге теста и перезапустите только соответствующий `-g` вариант.


