# Как мы нашли скрытые возможности оптимизации с помощью CDP

Привет, Хабр!

Есть такая штука в разработке библиотек компонентов — когда все вроде бы работает нормально, пользователи не жалуются, но где-то в глубине души подозреваешь, что можно сделать лучше. Особенно когда видишь в коде `requestAnimationFrame` в цикле.

Мы решили покопаться в производительности нашего кастомного скроллбара в библиотеке Taiga UI. Не потому что что-то тормозило, а просто из любопытства: а сколько вообще ресурсов он жрет? И можно ли меньше?

Спойлер: оказалось, что можно. И более того — мы научились это измерять и доказывать.

История про то, как Chrome DevTools Protocol помог превратить теоретические соображения об оптимизации в конкретные измеримые улучшения.

## Краткий ликбез по скроллбарам

Для начала разберемся, что у нас вообще есть в арсенале. В природе существует три вида скроллбаров, как три богатыря в русской сказке:

**Нативные скроллбары** — это дефолтные, которые браузер дает из коробки согласно [CSS Overflow Module Level 3](https://drafts.csswg.org/css-overflow-3/#scrollbars). Работают быстро, потому что живут прямо в недрах движка рендеринга. Но выглядят как хотят: на macOS — изящно, на Windows — как в 2010-м, на Linux — сюрприз каждый раз.

**CSS-скроллбары** через [`::-webkit-scrollbar`](https://webkit.org/blog/363/styling-scrollbars/) — попытка облагородить дефолт. Работают только в Chromium, в Firefox просто игнорируются. Как вишенка на торте, которую видят не все гости.

**Кастомные JS-скроллбары** — полный контроль, но вся ответственность на тебе. Именно такой живет в нашей библиотеке [Taiga UI](https://github.com/taiga-family/taiga-ui/tree/main/projects/core/components/scrollbar). И именно с ним у нас начались приключения.

## Наш герой — TuiScrollbar

TuiScrollbar — это наш кастомный компонент, который прячет уродливый нативный скроллбар и рисует красивый собственный. Звучит просто, но дьявол, как всегда, в деталях.

Главная задача — синхронизировать этот самодельный "бегунок" с реальным контентом. Прокрутили страницу — бегунок должен поехать. Загрузилась картинка — бегунок пересчитался. Анимация поменяла размеры — бегунок отреагировал. И все это должно работать плавно, без подвисаний.

## Когда жизнь усложняется

Со статическим контентом все просто — один раз посчитал размеры и живи спокойно. Но в реальном мире контент почти всегда динамический. И тут начинается веселье.

Вот реальные сценарии из нашей жизни:

**Сетка изображений**, которые грузятся асинхронно. Пока картинка не загрузилась, её высота нулевая. Как только прогрузилась — БАМ! — контейнер подпрыгивает на 200 пикселей. А скроллбар должен это отловить и пересчитаться.

**CSS Grid с динамическим контентом**. Добавили элемент — сетка перестроилась. Удалили — опять перестроилась. 

**Flexbox с изменяющимися элементами**. Анимация расширила блок, соседи подвинулись, общая высота изменилась.

Общий знаменатель у всех этих историй — DOM постоянно меняется. А наш скроллбар должен быть как хороший танцор: всегда в ритме, никогда не отстает.

## Исходная реализация: классический polling

Наш скроллбар изначально работал по классической схеме — постоянный опрос состояния через `requestAnimationFrame`:

```typescript
// Упрощенная версия изначального подхода
function updateScrollbarDimensions() {
    requestAnimationFrame(() => {
        const newDimensions = getCurrentDimensions();
        if (hasChanged(newDimensions)) {
            updateThumbPosition();
        }
        updateScrollbarDimensions(); // Рекурсивно
    });
}
```

Логика понятная: каждый кадр (60 раз в секунду) проверяем, не изменились ли размеры контента. Если изменились — обновляем позицию скроллбара. Работает стабильно, никто не жалуется.

Но тут появился вопрос: а эффективно ли это? 

### Теория: почему polling может быть дорогим

В браузерах есть понятие **[forced reflow](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)** — принудительный пересчет макета. Когда код запрашивает геометрические свойства элемента (`scrollHeight`, `clientHeight`, `getBoundingClientRect`), а DOM был изменен с момента последнего рендеринга, браузер вынужден синхронно пересчитать макет.

Наша гипотеза: даже если DOM не менялся, частые запросы размеров могут приводить к лишним проверкам и потенциальным reflow. Но это была именно гипотеза — нужны были измерения.

## Альтернативная идея: событийная архитектура

Появилась идея: а что если вместо постоянного опроса перейти на событийную модель? Подписаться на изменения и реагировать только тогда, когда что-то действительно происходит.

В современных браузерах для этого есть отличные инструменты:

- **[ResizeObserver](https://drafts.csswg.org/resize-observer/)** — уведомляет об изменениях размеров элементов
- **[MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)** — отслеживает изменения в DOM-дереве
- **scroll** — стандартное событие прокрутки

Концептуально новый подход выглядел так:

```typescript
// Событийная архитектура: реагируем на изменения
const dimensionUpdates$ = merge(
    resizeObserver$.pipe(debounceTime(100)),   // Элемент изменил размер
    mutationObserver$.pipe(debounceTime(100)), // DOM-дерево изменилось
    scrollEvent$.pipe(throttleTime(16))        // Произошла прокрутка
).pipe(
    distinctUntilChanged(),                    // Фильтруем дубликаты
    map(() => getCurrentDimensions())
);
```

Принцип: вместо "проверяю каждый кадр" получается "реагирую только на реальные события".

Но это все теория. Главный вопрос: а действительно ли такой подход эффективнее? И если да, то насколько именно?

## Знакомьтесь, Chrome DevTools Protocol

Тут в дело вступает **Chrome DevTools Protocol** ([официальная документация](https://chromedevtools.github.io/devtools-protocol/)) — это тот же API, которым пользуется сам Chrome DevTools. Только вместо кликания мышкой по вкладкам мы можем программно попросить браузер рассказать нам, что происходит под капотом.

CDP умеет много всего, но нас интересовала конкретно трассировка производительности. Можем отслеживать:

- Сколько раз браузер делал Layout (пересчет позиций)
- Сколько времени на это тратил
- Когда запускался RecalculateStyle (пересчет стилей)
- И много других метрик производительности

### Как это выглядит в коде

```typescript
// Говорим браузеру: "Начинай записывать все, что делаешь"
// Используем Playwright CDP API: https://playwright.dev/docs/api/class-cdpsession
await page._client.send('Tracing.start', {
    traceConfig: {
        includedCategories: ['devtools.timeline', 'blink.user_timing']
    }
});

// Тут происходит магия — крутим скроллбар
await executeScrollScenario(page);

// Останавливаем запись и получаем лог всех операций
const trace = await page._client.send('Tracing.end');

// Ищем интересные нам события
const layoutEvents = events.filter(e => e.name === 'Layout');
const recalcEvents = events.filter(e => e.name === 'RecalculateStyles');
```

В итоге получаем точные цифры: сколько раз браузер что-то пересчитывал и сколько времени на это потратил. Уже не "кажется работает быстрее", а "Layout операций стало на 30% меньше".

## Методология: как превратить гипотезы в факты

Самое интересное в этой истории — не сами оптимизации, а то, как мы научились их объективно измерять. Потому что "мне кажется, стало быстрее" — это не аргумент.

**Контролируемая среда**: Зафиксировали все переменные — одинаковый размер окна, отключенные сетевые запросы, стабильный CPU throttling. Ничего не должно влиять на результат, кроме нашего кода.

**Автоматизированные сценарии**: Написали Playwright-тесты, которые воспроизводят одинаковые паттерны скроллинга. Никаких ручных тестов — только детерминированные алгоритмы.

**Как считаем итоговые числа**: Для каждого варианта мы выполняем множество прогонов (обычно 15–20 в CI, для финальных сводок — до 50), фильтруем выбросы (IQR) и считаем среднее и стандартное отклонение.

**Изоляция факторов**: Тестируем только одно изменение за раз. RAF → события. Затем события → GPU. Каждая оптимизация измеряется отдельно.

Результат: объективные измеримые данные вместо субъективных впечатлений.

## Как мы тестируем: сценарии

Чтобы цифры были жизненными, мы прогоняем несколько фаз, которые воспроизводят типичные ситуации для компонентов со скроллом:

- Прокрутка с обновлением позиции «бегунка»
  - Стандартизированные шаги прокрутки, паузы между итерациями, одинаковый вьюпорт.
- Динамический контент
  - Во время прокрутки добавляем небольшие блоки внутрь первого `tui-scrollbar`, чтобы спровоцировать перестроение, пересчёт размеров и обновление «бегунка».
- «Только стили» (style-only)
  - Переключаем класс `t-style-toggle` у сотен потомков и периодически меняем CSS‑переменную на `:root` — это инвалидации стиль‑дерева без геометрических изменений, которые усиливают RecalculateStyle и имитируют тяжёлые темы/состояния.

Именно эта третья фаза (style-only) объясняет, почему у GPU‑варианта в свежих прогонов может быть выше счётчик RecalculateStyle при том, что Layout стабильно остаётся минимальным.

## Момент истины: результаты

И вот что у нас получилось после всех измерений:

### Обновление (август 2025)

Мы дополнили сценарии фазой «только стили» и пересчитали сводные метрики (15 прогонов, среднее ± стандартное отклонение) для трёх ключевых конфигураций:

| Вариант | Layout (операции) | RecalcStyle (операции) | Время Layout (мс) | Время RecalcStyle (мс) |
|---------|--------------------|------------------------|-------------------|------------------------|
| База (RAF: scroll‑controls + directive) | 76.0 ± 60.6 | 781.8 ± 84.2 | 22.63 ± 5.87 | 46.41 ± 8.02 |
| События (Resize + Mutation) | 75.8 ± 59.4 | 90.8 ± 64.5 | 23.29 ± 6.23 | 25.32 ± 5.67 |
| События + GPU (transform) | 40.3 ± 1.31 | 145.9 ± 79.4 | 18.37 ± 6.66 | 29.22 ± 7.38 |

Главное: вариант «События + GPU» уверенно выигрывает по Layout — операций примерно вдвое меньше, они ровные и предсказуемые (низкая дисперсия). Да, RecalculateStyle может быть выше, но UX выигрывает за счёт разгрузки Layout и передачи работы композитору.

### Почему у GPU‑варианта может быть выше RecalculateStyle

Мы осознанно избегаем «дорогих» Layout‑записей и обновляем «бегунок» через `transform/scale`, что уходит на композитор и в обычном случае не трогает геометрию. При этом мы всё равно меняем стиль (тот же `transform`), плюс в сценариях присутствуют динамические добавления элементов — в сумме это чаще инвалидирует стиль‑дерево. Итог: часть работы смещается из Layout в Style, а прокрутка становится ровнее.

## А что почувствует пользователь?

Цифры цифрами, но что это означает для обычного человека, который просто хочет прокрутить страницу?

**Плавность**: Меньше Layout операций = больше времени у браузера на сам рендеринг. Скроллинг становится более плавным, особенно на слабых устройствах.

**Отзывчивость**: Браузер меньше времени тратит на принудительные пересчеты, больше времени остается на реакцию на действия пользователя. Клики, наведения, анимации — все отзывается быстрее.

**Батарея**: На мобильных устройствах эффективный рендеринг = дольше работает батарея. Мелочь, а приятно.

Есть классические пороги восприятия:
- **16ms на кадр** — граница плавности (те самые 60 FPS)
- **100ms** — порог заметности задержки ("что-то подвисло")
- **1000ms** — порог терпения пользователя ("все, закрываю вкладку")

Наши оптимизации помогают оставаться в зеленой зоне даже при сложном динамическом контенте.

## Что дальше: от одного компонента к экосистеме

Когда у тебя есть рабочий инструмент измерения, появляется соблазн применить его везде. И это правильный соблазн.

**Автоматизация в CI/CD**: Теперь CDP-тесты можно встроить в pipeline и автоматически блокировать изменения, которые ухудшают производительность. "Извини, твой PR замедлил скроллбар на 15%, иди переписывай".

**Performance бюджеты**: Можно установить лимиты для каждого компонента. Например, "кнопка не должна делать больше 5 Layout операций при клике". Превысил — тест красный.

**Мониторинг в продакшене**: Адаптировать CDP-метрики для Real User Monitoring. Получать данные от реальных пользователей на реальных устройствах.

**Выборочное применение**: Не нужно измерять все подряд. CDP-тесты стоит применять к компонентам, которые:
- Часто используются
- Много работают с DOM
- Вызывают жалобы на производительность

Короче, теперь у нас есть не только быстрый скроллбар, но и инструменты, чтобы делать быстрыми другие компоненты.

## Что мы поняли

Эта история оказалась про методологию не меньше, чем про оптимизацию:

**Измерения превращают догадки в знания**. CDP дал нам возможность перейти от "теоретически должно быть быстрее" к "на 44% меньше Layout операций". Это совсем другой уровень понимания.

**Событийная архитектура действительно эффективнее polling'а**. Не просто архитектурно красивее, а измеримо быстрее. Теория подтвердилась практикой.

**GPU-ускорение работает**. CSS transforms vs прямое изменение layout-свойств — разница заметна в цифрах, не только в теории.

**Автоматизация измерений — это инвестиция в будущее**. Теперь любые изменения в производительности можно поймать автоматически, еще до продакшена.

## Полезные ссылки

**Исходники проекта:**
- [🔧 TuiScrollbar на GitHub](https://github.com/taiga-family/taiga-ui/tree/main/projects/core/components/scrollbar) — полная реализация компонента
- [📊 Playwright тесты](https://github.com/taiga-family/taiga-ui/tree/main/projects/demo-playwright) — CDP-тесты производительности

**Если хотите глубже изучить тему:**
- [📖 Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) — документация CDP
- [🤖 Playwright Performance Testing](https://playwright.dev/docs/test-performance) — гайд по автоматизации измерений
- [🚀 Web.dev Rendering Performance](https://web.dev/rendering-performance/) — основы оптимизации от Google
- [📊 CSS Triggers](https://csstriggers.com/) — какие свойства вызывают reflow/repaint

---

*А у вас есть опыт оптимизации производительности? Какие инструменты используете для измерений? Поделитесь в комментариях — будет интересно сравнить подходы!*

---

 

### 🎯 Анализ влияния throttling

Анализ различных значений throttling показывает:

- **10ms**: Минимальные улучшения при высокой нагрузке
- **16ms**: Оптимальный баланс производительности и отзывчивости  
- **32ms**: Хорошая производительность с небольшой задержкой
- **50ms**: Максимальная производительность, но заметная задержка

### 💡 Ключевые выводы из измерений

- **События + GPU**: минимальный и стабильный Layout (около 40 операций), лучшая плавность.
- **События > RAF** при равных задержках: меньше избыточной работы движка.
- **Практика**: throttle ≈ 16 мс, debounce ≈ 50 мс дают лучший баланс отзывчивости и нагрузки.

### 🔧 Оптимальная задержка: эксперименты и итог

Мы прогнали серию автоматизированных прогонов с разными задержками (0, 10–20 с шагом 2, 20–50 с шагом 5, 50–100 с шагом 10, 100–300 с шагом 50 мс) для трёх вариантов архитектуры:

- RAF (polling) в обоих местах (исторический baseline)
- Событийный (ResizeObserver + MutationObserver)
- Событийный + GPU (transform/scale)

Что получилось:

- RAF при 0 мс синхронизируется с кадром, но в нашем сценарии со style‑only фазой вызывает заметный всплеск RecalculateStyle — практический вывод: RAF как дефолт не используем, а если нужен, то не ниже 16 мс.
- Событийный вариант с ростом задержек снижает шум и стоимость перерасчётов, но теряет отзывчивость; «золотая середина» — область 16–50 мс.
- События + GPU держат Layout стабильно низким (~40 операций) почти независимо от задержки; увеличенный debounce уменьшает Recalc, но чуть «гасит» реакцию на резкие изменения размеров.

Итоговая рекомендация для продакшена:

- Событийный + GPU: throttle ≈ 16 мс (в такт 60 FPS), debounce ≈ 50 мс (сглаживает Resize/Mutation‑шум, не жертвуя UX).
- Если GPU недоступен/нежелателен: те же значения throttle/debounce показывают лучший баланс.
- RAF как базовый режим не рекомендуем, т.к. при равных условиях даёт больше лишней работы стиль‑дерева в наших сценариях.

---

**📁 Исходники и документация:**
- [🔧 Полная реализация TuiScrollbar](https://github.com/taiga-family/taiga-ui/tree/main/projects/core/components/scrollbar) — весь код компонента на GitHub
- [📊 Тесты производительности](./scrollbar-performance.pw.spec.ts) — CDP-тесты из этой статьи
- [📈 Результаты измерений](../../docs/scrollbar-performance/) — данные и графики
